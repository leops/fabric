use std::fmt::{self, Debug, Formatter};

use self::traits::NativeFunction;

use bitfield::bitfield;
use cranelift_codegen::{
    ir::{self, AbiParam},
    isa::CallConv,
};
use cranelift_wasm::{WasmFuncType, WasmType};
use target_lexicon::PointerWidth;

#[derive(Clone, Debug)]
pub(crate) struct Signature {
    pub(crate) wasm: WasmFuncType,
    pub(crate) clif: ir::Signature,
}

#[cfg(target_pointer_width = "64")]
pub(crate) const CALL_CONV: CallConv = CallConv::WindowsFastcall;
#[cfg(target_pointer_width = "32")]
pub(crate) const CALL_CONV: CallConv = CallConv::SystemV;

#[cfg(target_pointer_width = "64")]
pub(crate) const POINTER_WIDTH: PointerWidth = PointerWidth::U64;
#[cfg(target_pointer_width = "32")]
pub(crate) const POINTER_WIDTH: PointerWidth = PointerWidth::U32;

#[cfg(target_pointer_width = "64")]
const POINTER_TYPE: ir::Type = ir::types::R64;
#[cfg(target_pointer_width = "32")]
const POINTER_TYPE: ir::Type = ir::types::R32;

impl Signature {
    pub(crate) fn from_wasm(wasm: WasmFuncType, mut clif: ir::Signature) -> Self {
        for (clif, wasm) in clif.params.iter_mut().zip(wasm.params.iter()) {
            if *wasm == WasmType::ExternRef {
                clif.value_type = ir::types::I64;
            }
        }

        clif.params.insert(
            0,
            AbiParam::special(POINTER_TYPE, ir::ArgumentPurpose::VMContext),
        );

        Signature { wasm, clif }
    }

    pub(crate) fn check_wasm(&self, against: &WasmFuncType) {
        assert_eq!(
            self.wasm.params.len(),
            against.params.len(),
            "expected a function with {} parameters, found {}",
            self.wasm.params.len(),
            against.params.len(),
        );

        for (lhs, rhs) in self.wasm.params.iter().zip(against.params.iter()) {
            assert_eq!(lhs, rhs);
        }

        assert_eq!(self.wasm.returns.len(), against.returns.len());

        for (lhs, rhs) in self.wasm.returns.iter().zip(against.returns.iter()) {
            assert_eq!(lhs, rhs);
        }
    }

    pub(crate) fn check_clif(&self, against: &ir::Signature) {
        assert_eq!(self.clif.params.len(), against.params.len());

        for (lhs, rhs) in self.clif.params.iter().zip(against.params.iter()) {
            assert_eq!(lhs, rhs);
        }

        assert_eq!(self.clif.returns.len(), against.returns.len());

        for (lhs, rhs) in self.clif.returns.iter().zip(against.returns.iter()) {
            assert_eq!(lhs, rhs);
        }
    }
}

/// Handle to a native function, holds a pointer to the
/// function along with a definition of its signature
///
/// These values can be created directly from a Rust function,
/// or generated by the compiler from a WASM module
#[derive(Debug, Clone)]
pub struct Function {
    pub(crate) signature: Signature,
    pub(crate) pointer: *const u8,
}

impl Function {
    /// Create a new Function from a native Rust function
    pub fn new<T: NativeFunction>(func: T) -> Self {
        Function {
            signature: Signature {
                wasm: T::wasm_signature(),
                clif: T::clif_signature(),
            },
            pointer: func.into_pointer(),
        }
    }

    /// Obtain the function as a native Rust function pointer
    ///
    /// # Panic
    /// Panics if the request type doesn't match the stored function signature
    pub fn get<T: NativeFunction>(&self) -> T {
        self.signature.check_clif(&T::clif_signature());
        T::from_pointer(self.pointer)
    }
}

#[derive(Debug, PartialEq)]
enum ExternKind {
    Const = 0,
    Object = 1,
}

impl From<u8> for ExternKind {
    fn from(value: u8) -> Self {
        match value {
            0 => ExternKind::Const,
            1 => ExternKind::Object,
            _ => panic!("invalid ExternKind {}", value),
        }
    }
}

impl From<ExternKind> for u8 {
    fn from(value: ExternKind) -> Self {
        match value {
            ExternKind::Const => 0,
            ExternKind::Object => 1,
        }
    }
}

bitfield! {
    /// Reference to a value outside of the module sandbox
    ///
    /// ExternRefs are represented in memory with a 64 bits bitfield where:
    /// - The 8 low bits are used to store the type of external represented (a constant or a managed object)
    /// - Constants are stored inline in the high 32 bits
    /// - Managed objects are adressed through a generational index with the generation id stored in the
    /// middle 16 bits and the actual index stored in the high 32 bits
    #[repr(transparent)]
    #[derive(Copy, Clone)]
    pub struct ExternRef(u64);

    u8, from into ExternKind, kind, set_kind: 7, 0;

    u32, index, set_index: 63, 32;
    u16, generation, set_generation: 31, 16;

    u32, const_value, set_const_value: 63, 32;
}

impl Debug for ExternRef {
    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {
        match self.kind() {
            ExternKind::Const => fmt
                .debug_struct("ExternRef::Const")
                .field("value", &self.const_value())
                .finish(),
            ExternKind::Object => fmt
                .debug_struct("ExternRef::Object")
                .field("index", &self.index())
                .field("generation", &self.generation())
                .finish(),
        }
    }
}

impl ExternRef {
    pub(crate) fn from_const(value: u32) -> Self {
        let mut result = ExternRef(0);
        result.set_kind(ExternKind::Const);
        result.set_const_value(value);
        result
    }

    pub(crate) fn from_index_gen(index: u32, generation: u16) -> Self {
        let mut result = ExternRef(0);
        result.set_kind(ExternKind::Object);
        result.set_index(index);
        result.set_generation(generation);
        result
    }

    /// If this ExternRef is a constant, returns its value
    ///
    /// # Panic
    /// Panics if the ExternRef is not a constant
    pub fn value(&self) -> u32 {
        assert_eq!(self.kind(), ExternKind::Const);
        self.const_value()
    }

    pub(crate) fn index_gen(&self) -> (u32, u16) {
        assert_eq!(self.kind(), ExternKind::Object);
        (self.index(), self.generation())
    }
}

/// Helper macro for defining functions and function types with the correct
/// ABI for the current compilation target
#[cfg(target_pointer_width = "64")]
#[macro_export]
macro_rules! with_abi {
    ( $vis:vis fn $name:ident $args:tt -> $res:ty $body:block ) => {
        $vis extern "fastcall" fn $name $args -> $res $body
    };
    ( $vis:vis fn $name:ident $args:tt $body:block ) => {
        $vis extern "fastcall" fn $name $args $body
    };

    ( fn $args:tt -> $res:ty ) => {
        extern "fastcall" fn $args -> $res
    };
    ( fn $args:tt ) => {
        extern "fastcall" fn $args
    };
}

/// Helper macro for defining functions and function types with the correct
/// ABI for the current compilation target
#[cfg(target_pointer_width = "32")]
#[macro_export]
macro_rules! with_abi {
    ( $vis:vis fn $name:ident $args:tt -> $res:ty $body:block ) => {
        $vis extern "C" fn $name $args -> $res $body
    };
    ( $vis:vis fn $name:ident $args:tt $body:block ) => {
        $vis extern "C" fn $name $args $body
    };

    ( fn $args:tt -> $res:ty ) => {
        extern "C" fn $args -> $res
    };
    ( fn $args:tt ) => {
        extern "C" fn $args
    };
}

/// Reference to a function (generally defined in the module)
///
/// The in-memory value of structure is a 32 bits index in
/// the functions table of the module
#[repr(transparent)]
#[derive(Copy, Clone, Debug)]
pub struct FuncRef(pub(crate) u32);

mod traits {
    use std::intrinsics::transmute;

    use cranelift_codegen::ir::{self, AbiParam};
    use cranelift_wasm::{WasmFuncType, WasmType};

    use super::{ExternRef, FuncRef, CALL_CONV, POINTER_TYPE};
    use crate::backend::cranelift::VMContext;

    pub trait NativeFunction {
        fn wasm_signature() -> WasmFuncType;
        fn clif_signature() -> ir::Signature;
        fn into_pointer(self) -> *const u8;
        fn from_pointer(ptr: *const u8) -> Self;
    }

    macro_rules! impl_native_function {
    ( $( $type_args:ident ),* ) => {
        impl<E, R: ReturnType, $( $type_args: NativeType ),*> NativeFunction for with_abi!(fn( *mut VMContext<E>, $( $type_args ),* ) -> R) {
            fn wasm_signature() -> WasmFuncType {
                WasmFuncType {
                    params:  Vec::into_boxed_slice(vec![ $( $type_args::wasm_type() ),* ]),
                    returns: Vec::into_boxed_slice(if let Some(ty) = R::wasm_type() {
                        vec![ty]
                    } else {
                        Vec::new()
                    }),
                }
            }

            fn clif_signature() -> ir::Signature {
                let mut sig = ir::Signature::new(CALL_CONV);

                sig.params = vec![
                    AbiParam::special(
                        POINTER_TYPE,
                        ir::ArgumentPurpose::VMContext,
                    ),
                    $( AbiParam::new($type_args::clif_type()) ),*
                ];

                if let Some(ty) = R::clif_type() {
                    sig.returns = vec![
                        AbiParam::new(ty)
                    ];
                }

                sig
            }

            fn into_pointer(self) -> *const u8 {
                self as *const u8
            }

            fn from_pointer(ptr: *const u8) -> Self {
                unsafe { transmute(ptr) }
            }
        }
    };
}

    impl_native_function!();
    impl_native_function!(A1);
    impl_native_function!(A1, A2);
    impl_native_function!(A1, A2, A3);
    impl_native_function!(A1, A2, A3, A4);
    impl_native_function!(A1, A2, A3, A4, A5);

    pub trait NativeType {
        fn wasm_type() -> WasmType;
        fn clif_type() -> ir::Type;
    }

    pub trait ReturnType {
        fn wasm_type() -> Option<WasmType>;
        fn clif_type() -> Option<ir::Type>;
    }

    impl ReturnType for () {
        fn wasm_type() -> Option<WasmType> {
            None
        }

        fn clif_type() -> Option<ir::Type> {
            None
        }
    }

    macro_rules! impl_native_type {
        ( $ty:ty, $wasm:expr, $clif:expr ) => {
            impl NativeType for $ty {
                fn wasm_type() -> WasmType {
                    $wasm
                }

                fn clif_type() -> ir::Type {
                    $clif
                }
            }

            impl ReturnType for $ty {
                fn wasm_type() -> Option<WasmType> {
                    Some($wasm)
                }

                fn clif_type() -> Option<ir::Type> {
                    Some($clif)
                }
            }
        };
    }

    impl_native_type!(i32, WasmType::I32, ir::types::I32);
    impl_native_type!(i64, WasmType::I64, ir::types::I64);
    impl_native_type!(f32, WasmType::F32, ir::types::F32);
    impl_native_type!(f64, WasmType::F64, ir::types::F64);

    // Reference types are translated to integers instead of R32/R64 so they can be constructed inline
    // in the IR as an optimization (R* values can not be created using Cranelift instructions)
    impl_native_type!(ExternRef, WasmType::ExternRef, ir::types::I64);
    impl_native_type!(FuncRef, WasmType::FuncRef, ir::types::I32);
}
